from collections import namedtuple
import logging
from typing import Callable, List, Union

import torch

import operators as op


LOGGER = logging.getLogger(__name__)


# Holds a single piece of training data which consists of:
# 1. Program
# 2. A number of input-output pairs with outputs generated by the program.
# 3. The number of discard programs, for sanity checking.
Example = namedtuple(
    'Example',
    ['program', 'strings', 'num_discarded_programs'],
)


def randint(a: int, b: int) -> int:
    """
    Generate a random integer in the range [a, b).

    We use torch instead of Python's `random` so it is easy to set the seed.
    """
    return torch.randint(low=a, high=b, size=(1,)).item()


def randchoice(candidates: List):
    """Choose a random element from `candidates`."""
    idx = randint(0, len(candidates))
    return candidates[idx]


def sample_string(max_characters: int) -> str:
    """Generate a random string of length at most `max_characters`."""
    num_characters = randint(1, max_characters+1)
    random_string = ''.join((
        randchoice(op.CHARACTER)
        for _ in range(num_characters)
    ))
    return random_string


def sample_example(
        *,
        max_expressions: int = 10,
        max_characters: int = 100,
        max_empty_strings: int = 0,
        num_strings: int = 4,
        discard_program_num_empty: int = 100,
        discard_program_num_exceptions: int = 100) -> Example:
    """
    Generate a random example for training.

    :param max_expressions: Maximum number of expressions in a program.
    :param max_characters: Maximum number of characters in a string.
    :param max_empty_strings: Maximum number of empty transformed strings
        in the example.
    :param num_strings: Number of input-output pairs to generate per example.
    :param discard_program_num_empty: Number of empty strings a program
        produces before the program is discarded.
    :param discard_program_num_exceptions: Number of exceptions a program
        throws before the program is discarded.
    """
    num_discarded = 0
    while True:
        program = sample_program(max_expressions)

        num_empty, num_exception = 0, 0
        sampled_strings = []

        while True:
            string = sample_string(max_characters)
            try:
                transformed = program.eval(string)

                assert isinstance(transformed, str)

                if len(transformed) == 0:
                    num_empty += 1
                    if num_empty <= max_empty_strings:
                        sampled_strings.append((string, transformed))
                else:
                    sampled_strings.append((string, transformed))

            except IndexError:
                num_exception += 1

            if len(sampled_strings) == num_strings:
                return Example(program, sampled_strings, num_discarded)

            # We have to throw programs away because some of them always
            # throw IndexError's or produce empty strings.
            if (num_empty > discard_program_num_empty
                    or num_exception > discard_program_num_exceptions):
                LOGGER.debug('Throwing program away')
                LOGGER.debug(
                    'Empty: %s, exception: %s',
                    num_empty,
                    num_exception,
                )
                LOGGER.debug(program)
                num_discarded += 1
                break


def sample_program(max_expressions: int) -> op.Program:
    """
    Generate a random program with at most
    `max_expressions` expressions.
    """
    num_expressions = randint(1, max_expressions+1)
    return op.Concat(*[
        sample_expression()
        for _ in range(num_expressions)
    ])


def sample_from(*samplers: Callable[[], op.Expression]) -> op.Expression:
    """
    Helper function to generate a random expression from
    the given samplers.
    """
    choice = randchoice(samplers)
    return choice()


def sample_expression() -> op.Expression:
    """Generate a random expression."""
    return sample_from(
        sample_substring,
        sample_nesting,
        sample_Compose,
        sample_ConstStr,
    )


def sample_substring() -> op.Substring:
    """Generate a random substring."""
    return sample_from(
        sample_SubStr,
        sample_GetSpan,
    )


def sample_nesting() -> op.Nesting:
    """Generate a random nesting."""
    return sample_from(
        sample_GetToken,
        sample_ToCase,
        sample_Replace,
        sample_Trim,
        sample_GetUpto,
        sample_GetFrom,
        sample_GetFirst,
        sample_GetAll,
    )


def sample_Compose() -> op.Compose:
    """Generate a random Compose operator."""
    nesting = sample_nesting()
    nesting_or_substring = sample_from(
        sample_nesting,
        sample_substring,
    )
    return op.Compose(nesting, nesting_or_substring)


def sample_ConstStr() -> op.ConstStr:
    """Generate a random ConstStr operator."""
    char = randchoice(op.CHARACTER)
    return op.ConstStr(char)


def sample_position() -> int:
    """Generate a random position."""
    return randint(op.POSITION[0], op.POSITION[1]+1)


def sample_SubStr() -> op.SubStr:
    """Generate a random SubStr operator."""
    pos1 = sample_position()
    pos2 = sample_position()
    return op.SubStr(pos1, pos2)


def sample_Boundary() -> op.Boundary:
    """Generate a random boundary."""
    return randchoice(list(op.Boundary))


def sample_GetSpan() -> op.GetSpan:
    """Generate a random GetSpan operator."""
    return op.GetSpan(
        dsl_regex1=sample_dsl_regex(),
        index1=sample_index(),
        bound1=sample_Boundary(),
        dsl_regex2=sample_dsl_regex(),
        index2=sample_index(),
        bound2=sample_Boundary(),
    )


def sample_Type() -> op.Type:
    """Generate a random Type."""
    return randchoice(list(op.Type))


def sample_index() -> int:
    """Generate a random index."""
    return randchoice(op.INDEX)


def sample_GetToken() -> op.GetToken:
    """Generate a random GetToken operator."""
    type_ = sample_Type()
    index = sample_index()
    return op.GetToken(type_, index)


def sample_ToCase() -> op.ToCase:
    """Generate a random ToCase operator."""
    case = randchoice(list(op.Case))
    return op.ToCase(case)


def sample_delimiter() -> str:
    """Generate a random delimiter."""
    return randchoice(op.DELIMITER)


def sample_Replace() -> op.Replace:
    """Generate a random Replace operator."""
    delim1 = sample_delimiter()
    delim2 = sample_delimiter()
    return op.Replace(delim1, delim2)


def sample_Trim() -> op.Trim:
    """Generate a random Trim operator."""
    return op.Trim()


def sample_dsl_regex() -> Union[op.Type, str]:
    """Generate a random DSL regex."""
    return randchoice(list(op.Type) + list(op.DELIMITER))


def sample_GetUpto() -> op.GetUpto:
    """Generate a random GetUpto operator."""
    dsl_regex = sample_dsl_regex()
    return op.GetUpto(dsl_regex)


def sample_GetFrom() -> op.GetFrom:
    """Generate a random GetFrom operator."""
    dsl_regex = sample_dsl_regex()
    return op.GetFrom(dsl_regex)


def sample_GetFirst() -> op.GetFirst:
    """Generate a random GetFirst operator."""
    type_ = sample_Type()
    index = randchoice([
        i for i in op.INDEX
        if i > 0
    ])
    return op.GetFirst(type_, index)


def sample_GetAll() -> op.GetAll:
    """Generate a random GetAll operator."""
    type_ = sample_Type()
    return op.GetAll(type_)
